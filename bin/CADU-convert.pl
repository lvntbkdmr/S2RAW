#!/usr/bin/perl -s
#-------------------------------------------------------------------------------
#        1         2         3         4         5         6         7         8
#2345678901234567890123456789012345678901234567890123456789012345678901234567890
#-------------------------------------------------------------------------------
#
# 1.0 Created 15 Mar 2013  (Pierre VIAU)
#
# 1.1 Modified 23 Mar 2013  (Pierre VIAU)
# - added offset switch to allow skipping a header
# - added report of trailer (i.e. incomplete CADU) discarded if any
# - removed ALL conversions, everything is now byte-strings operations
#   (for performance and coherence reasons)
#
# 2.0 Modified 6 Apr 2013  (Pierre VIAU)
# - added possibility to process input VCDUs
# - added knowledge of VCDU annotations
# - added -in and -out options to define files content (CADU or VCDU)
# - modified annotation options, VCDU is a file type not a possible annotation (was dirty...)
# - improved instructions (more details)
#
# 2.1 Modified 10 Jul 2013  (Pierre VIAU)
# - added systematic list of VCID statistics
# - added option to NOT produce output file (to allow statistics only)
# - added instructions and one example for this
#
# 3.0 Modified 28 Sep 2013  (Pierre VIAU)
# - added option to split output per VCID
# - a better aligned printed output (will be fine until 1M frames)
# - cleaner printed output (no info on output if none is produced)
#
# 3.1 Modified 14 Nov 2013  (Pierre VIAU)
# - corrected bug: when in stat mode only (no output file), scrambled input option was ignored
# - always print VCID counter (was only when splitting output per VCID)
# - small optimization: calculate scrambling bytes for VCID only once (was at every frame)
#
#-------------------------------------------------------------------------------
#
# Script to transform CCSDS CADUs or VCDUs (loosely called frames here)
# using various options
#
# To this effect:
# - check cmd-line switches for options, and configure conversion process
# - read frame per frame; this assumes a CADU or VCDU fixed size, configured at the top
# - convert as indicated by options
# - write resulting frame to separate output file
# - if specified, split output to several files, 1 per VCID
#
# NB1: the output file name is derived from input file name,
#      appending (a) meaningful file extension(s) which depend(s) on the options
#
# USAGE: (but run the tool without parameters for definite up-to-date information)
# 
#   CADU-convert.pl <switches> <frames input file>
#
#   switches:
#	-in=xxx              input frames type
#	                     . xxx = CADU | VCDU
#	                     . if not set, =CADU is assumed by default
#	-out=yyy             output frames type
#	                     . yyy = CADU | VCDU | NONE
#	                     . if not set, output type will be same as input type
#	                     . =CADU cannot be set with -in=VCDU (no encoding function)
#	                     . =NONE no output file will be produced, only statistics if any
#	-in_scrambled        input frames are scrambled
#	                     . cannot be set with -in=VCDU (only CADUs are scrambled)
#	-out_scrambled       output frames will be scrambled
#	                     . if not set and -in_scrambled is, output will be unscrambled
#	                     . if set and -in_scrambled is not, output will be scrambled
#	                     . cannot be set with -out=VCDU (only CADUs are scrambled)
#	-in_annotated=zzz    input frames are annotated
#	                     . zzz = HRDFEP | HDR
#	-out_annotated       output frames will remain annotated
#	                     . if not set and -in_annotated is, annotations will be removed
#	                     . cannot be set if -in_annotated is not (no annotation function)
#	                     . cannot be set if -in=CADU and -out=VCDU (different types)
#	-offset=ttt          skip bytes at beginning of file
#	                     . ttt = n | AUTO
#	                     . =n skip n bytes
#	                     . =AUTO search for first sync marker
#                        . =AUTO cannot be set with -in=VCDU (no sync marker)
#	-no_idle             discard idle frames (works if scrambled or un-scrambled)
#	-per_VCID            split output to 1 file per VCID
#	-flip_sync           correct HDR LVDS bug: LSB storing of the sync marker
#	
# EXAMPLES (with trivial file names of course):
#	
#	CADU-convert.pl frames_file
#	. no effect (all switches off)
#	
#	CADU-convert.pl -out_scrambled CADUs_file
#	. scrambles CADUs to file CADUs_file.scrambled
#	
#	CADU-convert.pl -in_scrambled scrambled_CADUs_file
#	. unscrambles CADUs to file scrambled_CADUs_file.un-scrambled
#	
#	CADU-convert.pl -in_scrambled -in_annotated=HDR -no_idle HDR_scrambled_CADUs_file
#	. unscrambles, removes HDR annotations, discards idle frames
#	. and stores to file HDR_scrambled_CADUs_file.un-scrambled.not-annotated.no_idle
#	
#	CADU-convert.pl -in_scrambled -out_scrambled -no_idle scrambled_CADUs_file
#	. removes scrambled idle frames to file scrambled_CADUs_file.no-idle
#	
#	CADU-convert.pl -out_scrambled -in_annotated=HDR -out_annotated HDR_CADUs_file
#	. scrambles, keeps HDR annotations to file HDR_CADUs_file.scrambled
#	
#	CADU-convert.pl -in=VCDU -in_annotated=HRDFEP HRDFEP_VCDUs_file
#	. removes VCDU HDR annotations to file HRDFEP_VCDUs_file.not-annotated
#	
#	CADU-convert.pl -in=CADU -out=VCDU -in_scrambled -in_annotated=HDR -no_idle HDR_CADUs_file
#	. unscrambles CADUs, removes HDR annotations and converts to VCDUs
#	. and stores to file HDR_CADUs_file.un-scrambled.VCDU.not-annotated
#
#	CADU-convert.pl -stats -out=NONE -in_annotated=HDR -in_scrambled HDR_scrambled_CADUs_file
#	. unscrambles CADUs, removes HDR annotations
#	. no output file is generated, used only for listing VCID statistics
#	
#===============================================================================
# configuration section - touch if you know what you are doing

$B_SM 	    =    4;			# Sync Marker size in Bytes
$B_VCDU		= 1912;			# VCDU size in Bytes
$B_RS		=  128;			# Reed Solomon size in Bytes
# $B_ann	=     ;			# annotation size is set below depending on options
$B_ann_HDR_CADU		= 20;	# HDR CADU annotation size in Bytes
$B_ann_HDR_VCDU		= 16;	# HDR VCDU annotation size in Bytes
$B_ann_HRDFEP_CADU	= 10;	# HRDFEP CADU annotation size in Bytes
$B_ann_HRDFEP_VCDU	= 18;	# HRDFEP VCDU annotation size in Bytes

$B_search	= 1000;			# sync marker search block size in bytes; must be < $B_CADU size

$correct_SM = "\x1a\xcf\xfc\x1d";	# CADU sync marker in byte-string hex

$idle_VCID = "\x00\x3f";		# idle frame value in byte-string hex (63, bits 10-15)
$mask_VCID = "\x00\x3f";		# idle frame mask in byte-string hex (6 bits, bits 10-15)

# end of configuration section - do NOT touch anything below
#===============================================================================

$|++;	# disable output file buffering (only for debugging)

#-------------------------------------------------------------------------------
# check command-line arguments

if (($#ARGV < 0) or ($#ARGV > 0)) { 
	
	print "\nUSAGE:\n\n";
	print "\tCADU-convert.pl <switches> <frames input file>\n\n";

	print "\tswitches:\n";
	print "\t-in=xxx              input frames type\n";
	print "\t                     . xxx = CADU | VCDU\n";
	print "\t                     . if not set, =CADU is assumed by default\n";
	print "\t-out=yyy             output frames type\n";
	print "\t                     . yyy = CADU | VCDU | NONE\n";
	print "\t                     . if not set, output type will be same as input type\n";
	print "\t                     . =CADU cannot be set with -in=VCDU (no encoding function)\n";
	print "\t                     . =NONE no output file will be produced, only statistics\n";
	print "\t-in_scrambled        input frames are scrambled\n";
	print "\t                     . cannot be set with -in=VCDU (only CADUs are scrambled)\n";
	print "\t-out_scrambled       output frames will be scrambled\n";
	print "\t                     . if not set and -in_scrambled is, output will be unscrambled\n";
	print "\t                     . if set and -in_scrambled is not, output will be scrambled\n";
	print "\t                     . cannot be set with -out=VCDU (only CADUs are scrambled)\n";
	print "\t-in_annotated=zzz    input frames are annotated\n";
	print "\t                     . zzz = HRDFEP | HDR\n";
	print "\t-out_annotated       output frames will remain annotated\n";
	print "\t                     . if not set and -in_annotated is, annotations will be removed\n";
	print "\t                     . cannot be set if -in_annotated is not (no annotation function)\n";
	print "\t                     . cannot be set if -in=CADU and -out=VCDU (different types)\n";
	print "\t-offset=ttt          skip bytes at beginning of file\n";
	print "\t                     . ttt = n | AUTO\n";
	print "\t                     . =n skip n bytes\n";
	print "\t                     . =AUTO search for first sync marker\n";
	print "\t                     . =AUTO cannot be set with -in=VCDU (no sync marker)\n";
	print "\t-no_idle             discard idle frames (works if scrambled or un-scrambled)\n";
	print "\t-per_VCID            split output to 1 file per VCID\n";
	print "\t-flip_sync           correct HDR LVDS bug: LSB storing of the sync marker\n\n";
	
	print "EXAMPLES (with trivial file names of course):\n\n";
	
	print "\tCADU-convert.pl frames_file\n";
	print "\t. no effect (all switches off)\n\n";
	
	print "\tCADU-convert.pl -out_scrambled CADUs_file\n";
	print "\t. scrambles CADUs to file CADUs_file.scrambled\n\n";
	
	print "\tCADU-convert.pl -in_scrambled scrambled_CADUs_file\n";
	print "\t. unscrambles CADUs to file scrambled_CADUs_file.un-scrambled\n\n";
	
	print "\tCADU-convert.pl -in_scrambled -in_annotated=HDR -no_idle HDR_scrambled_CADUs_file\n";
	print "\t. unscrambles, removes HDR annotations, discards idle frames\n";
	print "\t. and stores to file HDR_scrambled_CADUs_file.un-scrambled.not-annotated.no_idle\n\n";
	
	print "\tCADU-convert.pl -in_scrambled -out_scrambled -no_idle scrambled_CADUs_file\n";
	print "\t. removes scrambled idle frames to file scrambled_CADUs_file.no-idle\n\n";
	
	print "\tCADU-convert.pl -out_scrambled -in_annotated=HDR -out_annotated HDR_CADUs_file\n";
	print "\t. scrambles, keeps HDR annotations to file HDR_CADUs_file.scrambled\n\n";
	
	print "\tCADU-convert.pl -in=VCDU -in_annotated=HRDFEP HRDFEP_VCDUs_file\n";
	print "\t. removes VCDU HDR annotations to file HRDFEP_VCDUs_file.not-annotated\n\n";
	
	print "\tCADU-convert.pl -in=CADU -out=VCDU -in_scrambled -in_annotated=HDR HDR_CADUs_file\n";
	print "\t. unscrambles CADUs, removes HDR annotations and converts to VCDUs\n";
	print "\t. and stores to file HDR_CADUs_file.VCDU.un-scrambled.not-annotated\n\n";
	
	print "\tCADU-convert.pl -out=NONE -in_annotated=HDR -in_scrambled HDR_scrambled_CADUs_file\n";
	print "\t. unscrambles CADUs, removes HDR annotations\n";
	print "\t. no output file is generated, used only for listing VCID statistics\n";

	die "\nTry again...\n\n";
}

#-------------------------------------------------------------------------------
# initialize options using command-line switches

print "----- options -----\n";

# derived options - initialized here, properly set in the logic statements below

$f_ext = "";		# outpout file extension
$output = 1;		# 0 = no output file, only statistics
$stats = 1;			# VCID statistics; always on (code is ready for an option, if switch is added)

$xor = 0;			# 1 = scramble / unscramble (same operation)
$B_ann = 0;			# annotation size in Bytes
$no_ann = 0;		# 1 = discard annotations
$only_VCDU = 0;		# 1 = output only VCDU part
$search_sync = 0;	# 1 = look for first sync marker (file with header)
$sync_found = 0;	# 1 = first sync marker has been found
$offset_read = 0;	# counter for header bytes skipped
$trailer_count = 0;	# trailing bytes found (i.e. incomplete CADU)
# $no_idle = ;		# directly set by the command-line switch (see below)

# ----- input and output data types -----

if ($in eq "CADU")
{
	print "input file assumed to contain CADUs\n";
}
elsif ($in eq "VCDU")
{
	print "input file assumed to to contain VCDUs\n";
}
elsif ($in eq "")		# CADUs assumed by default
{
	print "input file assumed to contain CADUs\n";
	$in = "CADU";
}
else
{
	die "\ninput file type unknown, aborting.\n\n";
}

if ($out eq "CADU")
{
	print "output file will contain CADUs\n";

	if ($in eq "VCDU") { die "\nVCDU input cannot be converted to CADU output, aborting.\n\n"; }
}
elsif ($out eq "VCDU")
{
	print "output file will contain VCDUs\n";

	if ($in eq "CADU")		# converting CADUs to VCDUs
	{
		$f_ext .= ".VCDU";
		$only_VCDU = 1;
		
		print "(if input data are scrambled <I don't know for sure>, make sure to un-scramble)\n";
	}
}
elsif ($out eq "")			# no conversion assumed by default
{
	print "output file will contain same data type as input\n";
	$out = $in;
}
elsif ($out eq "NONE")		# no output file
{
	print "output file is NOT requested\n";
	$output = 0;
}
else
{
	die "\noutput file type unknown, aborting.\n\n";
}

# ----- scrambling -----

if ($in_scrambled)
{
	print "input file assumed to be scrambled\n";
	
	if ($in eq "VCDU")
	{
		die "\ninput VCDU cannot be scrambled, aborting.\n\n";
	}

	if ($output)
	{
		if ($out_scrambled) 
		{
			print "output file will remain scrambled\n";

			if ($out eq "VCDU")
			{
				die "\noutput VCDU cannot be scrambled, aborting.\n\n";
			}
		}
		else
		{
			print "output file will be un-scrambled\n";
			$f_ext .= ".un-scrambled";
			$xor = 1;
		}
	}
}
else	# $in_scrambled = 0
{
	print "input file assumed to be un-scrambled\n";
	
	if ($output)
	{
		if ($out_scrambled) 
		{
			print "output file will be scrambled\n";
			$f_ext .= ".scrambled";
			$xor = 1;
		
			if ($out eq "VCDU")
			{
				die "\noutput VCDU cannot be scrambled, aborting.\n\n";
			}
		}
		else
		{
			print "output file will remain un-scrambled\n";
		}
	}
}

# ----- annotations -----

if ($in_annotated eq "HDR")
{	
	if ($in eq "CADU")		{ $B_ann = $B_ann_HDR_CADU; }
	elsif ($in eq "VCDU")	{ $B_ann = $B_ann_HDR_VCDU; }
	else { die "\ninput file type unknown, aborting.\n\n"; }

	print "input file assumed to have $in_annotated annotations ($B_ann bytes)\n";
}
elsif ($in_annotated eq "HRDFEP")
{
	if ($in eq "CADU")		{ $B_ann = $B_ann_HRDFEP_CADU; }
	elsif ($in eq "VCDU")	{ $B_ann = $B_ann_HRDFEP_VCDU; }
	else { die "\ninput file type unknown, aborting.\n\n"; }

	print "input file assumed to have $in_annotated annotations ($B_ann bytes)\n";
}
elsif ($in_annotated eq "")
{
	print "input file assumed to have no annotations\n";
}
else
{
	die "\ninput file annotations definition unknown, aborting.\n\n";
}

if ($output)
{
	if ($out_annotated)
	{
		print "output file will have same annotations as input\n";
	
		if ($in_annotated eq "") { die "\ninput file has no annotations, aborting.\n\n"; }
	
		if (($in eq "CADU") && ($out eq "VCDU")) { die "\nCADUs and VCDUs have incompatible 	annotations, aborting.\n\n"; }
	}
	else
	{
		if ($in_annotated)
		{
			print "output file will discard annotations\n";
			$f_ext .= ".no-annotation";
			$no_ann = 1;
		}
		else
		{
			print "output file will remain without annotations\n";
		}
	}
}

# ----- other options -----

if ($offset eq "AUTO")
{
	print "input file will be searched for 1st sync marker\n";
	$f_ext .= ".skip-header";
	$search_sync = 1;

	if ($in eq "VCDU") { die "\nVCDUs do not have sync markers, aborting.\n\n"; }
}
else
{
	$offset +=0;
	print "input file assumed to have $offset bytes header\n";
	if ($offset) { $f_ext .= ".skip-header"; }
}

if ($output)
{
	if ($no_idle)
	{
		print "output file will discard idle frames\n";
		$f_ext .= ".no-idle";
	
		print "(if input data are scrambled <I don't know for sure> make sure to mention it)\n";
	}
}

if ($output)
{
	if ($per_VCID)
	{
		print "1 output file per VCID will be produced\n";
		$f_ext .= ".VCIDxx";
	}
}

if ($output)
{
	if ($flip_sync)
	{
		print "output file will correct for sync marker LSB storage bug\n";
		$f_ext .= ".flip-sync";
	}
}

# if no options require any processing, stop now

if ($output)
{
	if ($f_ext eq "") 
	{
		if ($stats) 
		{
			$output = 0;
			print "\noutput file would be identical to input file";
		}
		else 
		{ 
			die "\nnothing to do, aborting.\n\n";
		}
	}
}

if (!$output)	{ print "\nno output file will be produced, only statistics listed\n"; }

#-------------------------------------------------------------------------------
# use remaining command-line arguments

print "----- files -----\n";

# open put file

$f_inFRAMEs  = $ARGV[0];
print "input file:    ".$f_inFRAMEs."\n";
open(inFRAMEs,  '<:raw', $f_inFRAMEs)  || die "\nCan't open file ".$f_inFRAMEs.", aborting.\n\n";

# open output file
# if $per_VCID, open an array of output files (empty files, if any, will be deleted at the end)

if ($output)
{
	$f_outFRAMEs = $f_inFRAMEs.$f_ext;
	
	if ($per_VCID)
	{
		print "output files:  ".$f_outFRAMEs."\n";
		print "(xx can be 00 to 63, only non-empty files will be produced)\n";
		
		for ($VC = 0; $VC < 64; $VC++)
		{
			$f_VC = sprintf "%02i", $VC;
			($f_outFRAMEs[$VC] = $f_outFRAMEs) =~ s|xx|$f_VC|;
			open($outFRAMEs[$VC], '>:raw', $f_outFRAMEs[$VC]) || die "\nCan't open file ".$f_outFRAMEs[$VC].", aborting.\n\n";
		}
	}
	else
	{
		print "output file:   ".$f_outFRAMEs."\n";
		open(outFRAMEs, '>:raw', $f_outFRAMEs) || die "\nCan't open file ".$f_outFRAMEs.", aborting.\n\n";
	}
}

#-------------------------------------------------------------------------------
# derived configuration (do not touch)

$B_payload 	= $B_VCDU + $B_RS;		# all-but-sync-marker size in Bytes
$B_CADU    	= $B_SM + $B_payload;	# CADU size in Bytes
$B_annCADU  = $B_CADU + $B_ann;		# annotated CADU size in Bytes
$B_annVCDU  = $B_VCDU + $B_ann;		# annotated VCDU size in Bytes

$b_SM		= $B_SM * 8;			# Sync Marker size in bits

$correct_SM_value = vec $correct_SM, 0, $b_SM;	# convert bits (NB: not Bytes) to decimal

#-------------------------------------------------------------------------------
# scrambling polynom values, pre-computed
#
# polynom is x8+x7+x5+x3+x
# see e.g. http://www.noaasis.noaa.gov/LRIT/pdf-files/5_LRIT_Mission-data.pdf
#
# repeating sequence of 255 bytes
# covering 1 full CADU i.e. 2040 bytes (sync marker excluded of course)

@polynom = (
0xff,0x48,0x0e,0xc0,0x9a,0x0d,0x70,0xbc,0x8e,0x2c,	#   10
0x93,0xad,0xa7,0xb7,0x46,0xce,0x5a,0x97,0x7d,0xcc,	#   20
0x32,0xa2,0xbf,0x3e,0x0a,0x10,0xf1,0x88,0x94,0xcd,	#   30
0xea,0xb1,0xfe,0x90,0x1d,0x81,0x34,0x1a,0xe1,0x79,	#   40
0x1c,0x59,0x27,0x5b,0x4f,0x6e,0x8d,0x9c,0xb5,0x2e,	#   50
0xfb,0x98,0x65,0x45,0x7e,0x7c,0x14,0x21,0xe3,0x11,	#   60
0x29,0x9b,0xd5,0x63,0xfd,0x20,0x3b,0x02,0x68,0x35,	#   70
0xc2,0xf2,0x38,0xb2,0x4e,0xb6,0x9e,0xdd,0x1b,0x39,	#   80
0x6a,0x5d,0xf7,0x30,0xca,0x8a,0xfc,0xf8,0x28,0x43,	#   90
0xc6,0x22,0x53,0x37,0xaa,0xc7,0xfa,0x40,0x76,0x04,	#  100
0xd0,0x6b,0x85,0xe4,0x71,0x64,0x9d,0x6d,0x3d,0xba,	#  110
0x36,0x72,0xd4,0xbb,0xee,0x61,0x95,0x15,0xf9,0xf0,	#  120
0x50,0x87,0x8c,0x44,0xa6,0x6f,0x55,0x8f,0xf4,0x80,	#  130
0xec,0x09,0xa0,0xd7,0x0b,0xc8,0xe2,0xc9,0x3a,0xda,	#  140
0x7b,0x74,0x6c,0xe5,0xa9,0x77,0xdc,0xc3,0x2a,0x2b,	#  150
0xf3,0xe0,0xa1,0x0f,0x18,0x89,0x4c,0xde,0xab,0x1f,	#  160
0xe9,0x01,0xd8,0x13,0x41,0xae,0x17,0x91,0xc5,0x92,	#  170
0x75,0xb4,0xf6,0xe8,0xd9,0xcb,0x52,0xef,0xb9,0x86,	#  180
0x54,0x57,0xe7,0xc1,0x42,0x1e,0x31,0x12,0x99,0xbd,	#  190
0x56,0x3f,0xd2,0x03,0xb0,0x26,0x83,0x5c,0x2f,0x23,	#  200
0x8b,0x24,0xeb,0x69,0xed,0xd1,0xb3,0x96,0xa5,0xdf,	#  210
0x73,0x0c,0xa8,0xaf,0xcf,0x82,0x84,0x3c,0x62,0x25,	#  220
0x33,0x7a,0xac,0x7f,0xa4,0x07,0x60,0x4d,0x06,0xb8,	#  230
0x5e,0x47,0x16,0x49,0xd6,0xd3,0xdb,0xa3,0x67,0x2d,	#  240
0x4b,0xbe,0xe6,0x19,0x51,0x5f,0x9f,0x05,0x08,0x78,	#  250
0xc4,0x4a,0x66,0xf5,0x58,0xff,0x48,0x0e,0xc0,0x9a,	#  260
0x0d,0x70,0xbc,0x8e,0x2c,0x93,0xad,0xa7,0xb7,0x46,	#  270
0xce,0x5a,0x97,0x7d,0xcc,0x32,0xa2,0xbf,0x3e,0x0a,	#  280
0x10,0xf1,0x88,0x94,0xcd,0xea,0xb1,0xfe,0x90,0x1d,	#  290
0x81,0x34,0x1a,0xe1,0x79,0x1c,0x59,0x27,0x5b,0x4f,	#  300
0x6e,0x8d,0x9c,0xb5,0x2e,0xfb,0x98,0x65,0x45,0x7e,	#  310
0x7c,0x14,0x21,0xe3,0x11,0x29,0x9b,0xd5,0x63,0xfd,	#  320
0x20,0x3b,0x02,0x68,0x35,0xc2,0xf2,0x38,0xb2,0x4e,	#  330
0xb6,0x9e,0xdd,0x1b,0x39,0x6a,0x5d,0xf7,0x30,0xca,	#  340
0x8a,0xfc,0xf8,0x28,0x43,0xc6,0x22,0x53,0x37,0xaa,	#  350
0xc7,0xfa,0x40,0x76,0x04,0xd0,0x6b,0x85,0xe4,0x71,	#  360
0x64,0x9d,0x6d,0x3d,0xba,0x36,0x72,0xd4,0xbb,0xee,	#  370
0x61,0x95,0x15,0xf9,0xf0,0x50,0x87,0x8c,0x44,0xa6,	#  380
0x6f,0x55,0x8f,0xf4,0x80,0xec,0x09,0xa0,0xd7,0x0b,	#  390
0xc8,0xe2,0xc9,0x3a,0xda,0x7b,0x74,0x6c,0xe5,0xa9,	#  400
0x77,0xdc,0xc3,0x2a,0x2b,0xf3,0xe0,0xa1,0x0f,0x18,	#  410
0x89,0x4c,0xde,0xab,0x1f,0xe9,0x01,0xd8,0x13,0x41,	#  420
0xae,0x17,0x91,0xc5,0x92,0x75,0xb4,0xf6,0xe8,0xd9,	#  430
0xcb,0x52,0xef,0xb9,0x86,0x54,0x57,0xe7,0xc1,0x42,	#  440
0x1e,0x31,0x12,0x99,0xbd,0x56,0x3f,0xd2,0x03,0xb0,	#  450
0x26,0x83,0x5c,0x2f,0x23,0x8b,0x24,0xeb,0x69,0xed,	#  460
0xd1,0xb3,0x96,0xa5,0xdf,0x73,0x0c,0xa8,0xaf,0xcf,	#  470
0x82,0x84,0x3c,0x62,0x25,0x33,0x7a,0xac,0x7f,0xa4,	#  480
0x07,0x60,0x4d,0x06,0xb8,0x5e,0x47,0x16,0x49,0xd6,	#  490
0xd3,0xdb,0xa3,0x67,0x2d,0x4b,0xbe,0xe6,0x19,0x51,	#  500
0x5f,0x9f,0x05,0x08,0x78,0xc4,0x4a,0x66,0xf5,0x58,	#  510
0xff,0x48,0x0e,0xc0,0x9a,0x0d,0x70,0xbc,0x8e,0x2c,	#  520
0x93,0xad,0xa7,0xb7,0x46,0xce,0x5a,0x97,0x7d,0xcc,	#  530
0x32,0xa2,0xbf,0x3e,0x0a,0x10,0xf1,0x88,0x94,0xcd,	#  540
0xea,0xb1,0xfe,0x90,0x1d,0x81,0x34,0x1a,0xe1,0x79,	#  550
0x1c,0x59,0x27,0x5b,0x4f,0x6e,0x8d,0x9c,0xb5,0x2e,	#  560
0xfb,0x98,0x65,0x45,0x7e,0x7c,0x14,0x21,0xe3,0x11,	#  570
0x29,0x9b,0xd5,0x63,0xfd,0x20,0x3b,0x02,0x68,0x35,	#  580
0xc2,0xf2,0x38,0xb2,0x4e,0xb6,0x9e,0xdd,0x1b,0x39,	#  590
0x6a,0x5d,0xf7,0x30,0xca,0x8a,0xfc,0xf8,0x28,0x43,	#  600
0xc6,0x22,0x53,0x37,0xaa,0xc7,0xfa,0x40,0x76,0x04,	#  610
0xd0,0x6b,0x85,0xe4,0x71,0x64,0x9d,0x6d,0x3d,0xba,	#  620
0x36,0x72,0xd4,0xbb,0xee,0x61,0x95,0x15,0xf9,0xf0,	#  630
0x50,0x87,0x8c,0x44,0xa6,0x6f,0x55,0x8f,0xf4,0x80,	#  640
0xec,0x09,0xa0,0xd7,0x0b,0xc8,0xe2,0xc9,0x3a,0xda,	#  650
0x7b,0x74,0x6c,0xe5,0xa9,0x77,0xdc,0xc3,0x2a,0x2b,	#  660
0xf3,0xe0,0xa1,0x0f,0x18,0x89,0x4c,0xde,0xab,0x1f,	#  670
0xe9,0x01,0xd8,0x13,0x41,0xae,0x17,0x91,0xc5,0x92,	#  680
0x75,0xb4,0xf6,0xe8,0xd9,0xcb,0x52,0xef,0xb9,0x86,	#  690
0x54,0x57,0xe7,0xc1,0x42,0x1e,0x31,0x12,0x99,0xbd,	#  700
0x56,0x3f,0xd2,0x03,0xb0,0x26,0x83,0x5c,0x2f,0x23,	#  710
0x8b,0x24,0xeb,0x69,0xed,0xd1,0xb3,0x96,0xa5,0xdf,	#  720
0x73,0x0c,0xa8,0xaf,0xcf,0x82,0x84,0x3c,0x62,0x25,	#  730
0x33,0x7a,0xac,0x7f,0xa4,0x07,0x60,0x4d,0x06,0xb8,	#  740
0x5e,0x47,0x16,0x49,0xd6,0xd3,0xdb,0xa3,0x67,0x2d,	#  750
0x4b,0xbe,0xe6,0x19,0x51,0x5f,0x9f,0x05,0x08,0x78,	#  760
0xc4,0x4a,0x66,0xf5,0x58,0xff,0x48,0x0e,0xc0,0x9a,	#  770
0x0d,0x70,0xbc,0x8e,0x2c,0x93,0xad,0xa7,0xb7,0x46,	#  780
0xce,0x5a,0x97,0x7d,0xcc,0x32,0xa2,0xbf,0x3e,0x0a,	#  790
0x10,0xf1,0x88,0x94,0xcd,0xea,0xb1,0xfe,0x90,0x1d,	#  800
0x81,0x34,0x1a,0xe1,0x79,0x1c,0x59,0x27,0x5b,0x4f,	#  810
0x6e,0x8d,0x9c,0xb5,0x2e,0xfb,0x98,0x65,0x45,0x7e,	#  820
0x7c,0x14,0x21,0xe3,0x11,0x29,0x9b,0xd5,0x63,0xfd,	#  830
0x20,0x3b,0x02,0x68,0x35,0xc2,0xf2,0x38,0xb2,0x4e,	#  840
0xb6,0x9e,0xdd,0x1b,0x39,0x6a,0x5d,0xf7,0x30,0xca,	#  850
0x8a,0xfc,0xf8,0x28,0x43,0xc6,0x22,0x53,0x37,0xaa,	#  860
0xc7,0xfa,0x40,0x76,0x04,0xd0,0x6b,0x85,0xe4,0x71,	#  870
0x64,0x9d,0x6d,0x3d,0xba,0x36,0x72,0xd4,0xbb,0xee,	#  880
0x61,0x95,0x15,0xf9,0xf0,0x50,0x87,0x8c,0x44,0xa6,	#  890
0x6f,0x55,0x8f,0xf4,0x80,0xec,0x09,0xa0,0xd7,0x0b,	#  900
0xc8,0xe2,0xc9,0x3a,0xda,0x7b,0x74,0x6c,0xe5,0xa9,	#  910
0x77,0xdc,0xc3,0x2a,0x2b,0xf3,0xe0,0xa1,0x0f,0x18,	#  920
0x89,0x4c,0xde,0xab,0x1f,0xe9,0x01,0xd8,0x13,0x41,	#  930
0xae,0x17,0x91,0xc5,0x92,0x75,0xb4,0xf6,0xe8,0xd9,	#  940
0xcb,0x52,0xef,0xb9,0x86,0x54,0x57,0xe7,0xc1,0x42,	#  950
0x1e,0x31,0x12,0x99,0xbd,0x56,0x3f,0xd2,0x03,0xb0,	#  960
0x26,0x83,0x5c,0x2f,0x23,0x8b,0x24,0xeb,0x69,0xed,	#  970
0xd1,0xb3,0x96,0xa5,0xdf,0x73,0x0c,0xa8,0xaf,0xcf,	#  980
0x82,0x84,0x3c,0x62,0x25,0x33,0x7a,0xac,0x7f,0xa4,	#  990
0x07,0x60,0x4d,0x06,0xb8,0x5e,0x47,0x16,0x49,0xd6,	# 1000
0xd3,0xdb,0xa3,0x67,0x2d,0x4b,0xbe,0xe6,0x19,0x51,	# 1010
0x5f,0x9f,0x05,0x08,0x78,0xc4,0x4a,0x66,0xf5,0x58,	# 1020
0xff,0x48,0x0e,0xc0,0x9a,0x0d,0x70,0xbc,0x8e,0x2c,	# 1030
0x93,0xad,0xa7,0xb7,0x46,0xce,0x5a,0x97,0x7d,0xcc,	# 1040
0x32,0xa2,0xbf,0x3e,0x0a,0x10,0xf1,0x88,0x94,0xcd,	# 1050
0xea,0xb1,0xfe,0x90,0x1d,0x81,0x34,0x1a,0xe1,0x79,	# 1060
0x1c,0x59,0x27,0x5b,0x4f,0x6e,0x8d,0x9c,0xb5,0x2e,	# 1070
0xfb,0x98,0x65,0x45,0x7e,0x7c,0x14,0x21,0xe3,0x11,	# 1080
0x29,0x9b,0xd5,0x63,0xfd,0x20,0x3b,0x02,0x68,0x35,	# 1090
0xc2,0xf2,0x38,0xb2,0x4e,0xb6,0x9e,0xdd,0x1b,0x39,	# 1100
0x6a,0x5d,0xf7,0x30,0xca,0x8a,0xfc,0xf8,0x28,0x43,	# 1110
0xc6,0x22,0x53,0x37,0xaa,0xc7,0xfa,0x40,0x76,0x04,	# 1120
0xd0,0x6b,0x85,0xe4,0x71,0x64,0x9d,0x6d,0x3d,0xba,	# 1130
0x36,0x72,0xd4,0xbb,0xee,0x61,0x95,0x15,0xf9,0xf0,	# 1140
0x50,0x87,0x8c,0x44,0xa6,0x6f,0x55,0x8f,0xf4,0x80,	# 1150
0xec,0x09,0xa0,0xd7,0x0b,0xc8,0xe2,0xc9,0x3a,0xda,	# 1160
0x7b,0x74,0x6c,0xe5,0xa9,0x77,0xdc,0xc3,0x2a,0x2b,	# 1170
0xf3,0xe0,0xa1,0x0f,0x18,0x89,0x4c,0xde,0xab,0x1f,	# 1180
0xe9,0x01,0xd8,0x13,0x41,0xae,0x17,0x91,0xc5,0x92,	# 1190
0x75,0xb4,0xf6,0xe8,0xd9,0xcb,0x52,0xef,0xb9,0x86,	# 1200
0x54,0x57,0xe7,0xc1,0x42,0x1e,0x31,0x12,0x99,0xbd,	# 1210
0x56,0x3f,0xd2,0x03,0xb0,0x26,0x83,0x5c,0x2f,0x23,	# 1220
0x8b,0x24,0xeb,0x69,0xed,0xd1,0xb3,0x96,0xa5,0xdf,	# 1230
0x73,0x0c,0xa8,0xaf,0xcf,0x82,0x84,0x3c,0x62,0x25,	# 1240
0x33,0x7a,0xac,0x7f,0xa4,0x07,0x60,0x4d,0x06,0xb8,	# 1250
0x5e,0x47,0x16,0x49,0xd6,0xd3,0xdb,0xa3,0x67,0x2d,	# 1260
0x4b,0xbe,0xe6,0x19,0x51,0x5f,0x9f,0x05,0x08,0x78,	# 1270
0xc4,0x4a,0x66,0xf5,0x58,0xff,0x48,0x0e,0xc0,0x9a,	# 1280
0x0d,0x70,0xbc,0x8e,0x2c,0x93,0xad,0xa7,0xb7,0x46,	# 1290
0xce,0x5a,0x97,0x7d,0xcc,0x32,0xa2,0xbf,0x3e,0x0a,	# 1300
0x10,0xf1,0x88,0x94,0xcd,0xea,0xb1,0xfe,0x90,0x1d,	# 1310
0x81,0x34,0x1a,0xe1,0x79,0x1c,0x59,0x27,0x5b,0x4f,	# 1320
0x6e,0x8d,0x9c,0xb5,0x2e,0xfb,0x98,0x65,0x45,0x7e,	# 1330
0x7c,0x14,0x21,0xe3,0x11,0x29,0x9b,0xd5,0x63,0xfd,	# 1340
0x20,0x3b,0x02,0x68,0x35,0xc2,0xf2,0x38,0xb2,0x4e,	# 1350
0xb6,0x9e,0xdd,0x1b,0x39,0x6a,0x5d,0xf7,0x30,0xca,	# 1360
0x8a,0xfc,0xf8,0x28,0x43,0xc6,0x22,0x53,0x37,0xaa,	# 1370
0xc7,0xfa,0x40,0x76,0x04,0xd0,0x6b,0x85,0xe4,0x71,	# 1380
0x64,0x9d,0x6d,0x3d,0xba,0x36,0x72,0xd4,0xbb,0xee,	# 1390
0x61,0x95,0x15,0xf9,0xf0,0x50,0x87,0x8c,0x44,0xa6,	# 1400
0x6f,0x55,0x8f,0xf4,0x80,0xec,0x09,0xa0,0xd7,0x0b,	# 1410
0xc8,0xe2,0xc9,0x3a,0xda,0x7b,0x74,0x6c,0xe5,0xa9,	# 1420
0x77,0xdc,0xc3,0x2a,0x2b,0xf3,0xe0,0xa1,0x0f,0x18,	# 1430
0x89,0x4c,0xde,0xab,0x1f,0xe9,0x01,0xd8,0x13,0x41,	# 1440
0xae,0x17,0x91,0xc5,0x92,0x75,0xb4,0xf6,0xe8,0xd9,	# 1450
0xcb,0x52,0xef,0xb9,0x86,0x54,0x57,0xe7,0xc1,0x42,	# 1460
0x1e,0x31,0x12,0x99,0xbd,0x56,0x3f,0xd2,0x03,0xb0,	# 1470
0x26,0x83,0x5c,0x2f,0x23,0x8b,0x24,0xeb,0x69,0xed,	# 1480
0xd1,0xb3,0x96,0xa5,0xdf,0x73,0x0c,0xa8,0xaf,0xcf,	# 1490
0x82,0x84,0x3c,0x62,0x25,0x33,0x7a,0xac,0x7f,0xa4,	# 1500
0x07,0x60,0x4d,0x06,0xb8,0x5e,0x47,0x16,0x49,0xd6,	# 1510
0xd3,0xdb,0xa3,0x67,0x2d,0x4b,0xbe,0xe6,0x19,0x51,	# 1520
0x5f,0x9f,0x05,0x08,0x78,0xc4,0x4a,0x66,0xf5,0x58,	# 1530
0xff,0x48,0x0e,0xc0,0x9a,0x0d,0x70,0xbc,0x8e,0x2c,	# 1540
0x93,0xad,0xa7,0xb7,0x46,0xce,0x5a,0x97,0x7d,0xcc,	# 1550
0x32,0xa2,0xbf,0x3e,0x0a,0x10,0xf1,0x88,0x94,0xcd,	# 1560
0xea,0xb1,0xfe,0x90,0x1d,0x81,0x34,0x1a,0xe1,0x79,	# 1570
0x1c,0x59,0x27,0x5b,0x4f,0x6e,0x8d,0x9c,0xb5,0x2e,	# 1580
0xfb,0x98,0x65,0x45,0x7e,0x7c,0x14,0x21,0xe3,0x11,	# 1590
0x29,0x9b,0xd5,0x63,0xfd,0x20,0x3b,0x02,0x68,0x35,	# 1600
0xc2,0xf2,0x38,0xb2,0x4e,0xb6,0x9e,0xdd,0x1b,0x39,	# 1610
0x6a,0x5d,0xf7,0x30,0xca,0x8a,0xfc,0xf8,0x28,0x43,	# 1620
0xc6,0x22,0x53,0x37,0xaa,0xc7,0xfa,0x40,0x76,0x04,	# 1630
0xd0,0x6b,0x85,0xe4,0x71,0x64,0x9d,0x6d,0x3d,0xba,	# 1640
0x36,0x72,0xd4,0xbb,0xee,0x61,0x95,0x15,0xf9,0xf0,	# 1650
0x50,0x87,0x8c,0x44,0xa6,0x6f,0x55,0x8f,0xf4,0x80,	# 1660
0xec,0x09,0xa0,0xd7,0x0b,0xc8,0xe2,0xc9,0x3a,0xda,	# 1670
0x7b,0x74,0x6c,0xe5,0xa9,0x77,0xdc,0xc3,0x2a,0x2b,	# 1680
0xf3,0xe0,0xa1,0x0f,0x18,0x89,0x4c,0xde,0xab,0x1f,	# 1690
0xe9,0x01,0xd8,0x13,0x41,0xae,0x17,0x91,0xc5,0x92,	# 1700
0x75,0xb4,0xf6,0xe8,0xd9,0xcb,0x52,0xef,0xb9,0x86,	# 1710
0x54,0x57,0xe7,0xc1,0x42,0x1e,0x31,0x12,0x99,0xbd,	# 1720
0x56,0x3f,0xd2,0x03,0xb0,0x26,0x83,0x5c,0x2f,0x23,	# 1730
0x8b,0x24,0xeb,0x69,0xed,0xd1,0xb3,0x96,0xa5,0xdf,	# 1740
0x73,0x0c,0xa8,0xaf,0xcf,0x82,0x84,0x3c,0x62,0x25,	# 1750
0x33,0x7a,0xac,0x7f,0xa4,0x07,0x60,0x4d,0x06,0xb8,	# 1760
0x5e,0x47,0x16,0x49,0xd6,0xd3,0xdb,0xa3,0x67,0x2d,	# 1770
0x4b,0xbe,0xe6,0x19,0x51,0x5f,0x9f,0x05,0x08,0x78,	# 1780
0xc4,0x4a,0x66,0xf5,0x58,0xff,0x48,0x0e,0xc0,0x9a,	# 1790
0x0d,0x70,0xbc,0x8e,0x2c,0x93,0xad,0xa7,0xb7,0x46,	# 1800
0xce,0x5a,0x97,0x7d,0xcc,0x32,0xa2,0xbf,0x3e,0x0a,	# 1810
0x10,0xf1,0x88,0x94,0xcd,0xea,0xb1,0xfe,0x90,0x1d,	# 1820
0x81,0x34,0x1a,0xe1,0x79,0x1c,0x59,0x27,0x5b,0x4f,	# 1830
0x6e,0x8d,0x9c,0xb5,0x2e,0xfb,0x98,0x65,0x45,0x7e,	# 1840
0x7c,0x14,0x21,0xe3,0x11,0x29,0x9b,0xd5,0x63,0xfd,	# 1850
0x20,0x3b,0x02,0x68,0x35,0xc2,0xf2,0x38,0xb2,0x4e,	# 1860
0xb6,0x9e,0xdd,0x1b,0x39,0x6a,0x5d,0xf7,0x30,0xca,	# 1870
0x8a,0xfc,0xf8,0x28,0x43,0xc6,0x22,0x53,0x37,0xaa,	# 1880
0xc7,0xfa,0x40,0x76,0x04,0xd0,0x6b,0x85,0xe4,0x71,	# 1890
0x64,0x9d,0x6d,0x3d,0xba,0x36,0x72,0xd4,0xbb,0xee,	# 1900
0x61,0x95,0x15,0xf9,0xf0,0x50,0x87,0x8c,0x44,0xa6,	# 1910
0x6f,0x55,0x8f,0xf4,0x80,0xec,0x09,0xa0,0xd7,0x0b,	# 1920
0xc8,0xe2,0xc9,0x3a,0xda,0x7b,0x74,0x6c,0xe5,0xa9,	# 1930
0x77,0xdc,0xc3,0x2a,0x2b,0xf3,0xe0,0xa1,0x0f,0x18,	# 1940
0x89,0x4c,0xde,0xab,0x1f,0xe9,0x01,0xd8,0x13,0x41,	# 1950
0xae,0x17,0x91,0xc5,0x92,0x75,0xb4,0xf6,0xe8,0xd9,	# 1960
0xcb,0x52,0xef,0xb9,0x86,0x54,0x57,0xe7,0xc1,0x42,	# 1970
0x1e,0x31,0x12,0x99,0xbd,0x56,0x3f,0xd2,0x03,0xb0,	# 1980
0x26,0x83,0x5c,0x2f,0x23,0x8b,0x24,0xeb,0x69,0xed,	# 1990
0xd1,0xb3,0x96,0xa5,0xdf,0x73,0x0c,0xa8,0xaf,0xcf,	# 2000
0x82,0x84,0x3c,0x62,0x25,0x33,0x7a,0xac,0x7f,0xa4,	# 2010
0x07,0x60,0x4d,0x06,0xb8,0x5e,0x47,0x16,0x49,0xd6,	# 2020
0xd3,0xdb,0xa3,0x67,0x2d,0x4b,0xbe,0xe6,0x19,0x51,	# 2030
0x5f,0x9f,0x05,0x08,0x78,0xc4,0x4a,0x66,0xf5,0x58	# 2040
);

$polynom_pack_format ="C".$B_payload;				# same size as CADU payload
$polynom_bytes	= pack($polynom_pack_format, @polynom);
$polynom_2bytes	= substr $polynom_bytes, 0, 2;		# first 2 bytes (contain VCID)

#===============================================================================

# initialisation

$n_FRAMEs = 0;		# total FRAME count
$n_niFRAMEs = 0;	# non-idle FRAME count

print "----- processing -----\n";

# skip header if any -----------------------------------------------------------

if ($search_sync)
{	
	$bytes_read = 0;
	
	while (($bytes_read = read(inFRAMEs, $search_bytes, $B_search, 0)) > 3)	# if 3 bytes left, no sync possible
	{
		$SM_offset = index $search_bytes, $correct_SM;		# byte offset for sync marker

		if ($SM_offset == -1)		# no sync marker found in this block
		{
			$offset_read += $bytes_read - $B_SM + 1;	# count bytes skipped
			
			printf "searching for sync marker %x... skipping $offset_read bytes", $correct_SM_value;
			print "\r";
			
			$rewind = tell(inFRAMEs) - $B_SM + 1;	# go back 3 bytes
			seek(inFRAMEs, $rewind, 0);				
		}
		else						# sync marker found in this block
		{
			$offset_read += $SM_offset;				# count bytes skipped
			
			printf "searching for sync marker %x... found after $offset_read bytes", $correct_SM_value;
			print "\n";
			
			$rewind = tell(inFRAMEs) - $bytes_read + $SM_offset;	# go back to sync marker
			seek(inFRAMEs, $rewind, 0);

			$sync_found = 1;
			last;					# stop searching (exit loop)
		}
	}
	
	if ( ! $sync_found)
	{
		printf "\nsync marker %x not found, aborting.\n\n", $correct_SM_value;
		die;
	}
}
else
{
	$offset_read = read(inFRAMEs, $offset_bytes, $offset, 0);
}

print "$offset_read header bytes skipped\n", ;

# read one frame at a time, process, write one frame at a time -----------------

$bytes_read = 0;
	
if ($in eq "CADU")		# input is CADUs
{
	while ($bytes_read = read(inFRAMEs, $annCADU_bytes, $B_annCADU, 0))
	{
		if ($bytes_read == $B_annCADU)
		{
			printf "CADU %8d,   $bytes_read bytes", ++$n_FRAMEs;
			
			# ----- process sync marker -----
			
			$SM_bytes = substr $annCADU_bytes, 0, $B_SM;			# sync marker only
		
			if ($flip_sync)		# need to put back sync marker in MSB
			{
				$SM_bytes = pack("B".$b_SM, unpack("b".$b_SM, $SM_bytes));
			}
	
			if ($SM_bytes eq $correct_SM)
			{
				printf ",   sync = %x", $correct_SM_value;
			}
			else
			{
				$SM = vec $SM_bytes, 0, $b_SM;			# convert bits (NB: not Bytes) to decimal
				printf ",   sync = %x", $SM;
				die ",   Wrong Sync Marker, aborting.\n\n";
			}
			
			# ----- retrieve CADU payload -----
		
			$payload_bytes = substr $annCADU_bytes, $B_SM, $B_payload;	# CADU without sync marker
		
			# ----- decode VCID -----
		
			$payload_2bytes = substr $payload_bytes, 0, 2;		# first 2 bytes
		
			if ($in_scrambled)		# need to xor to decode VCID
			{
				$payload_2bytes = $payload_2bytes ^ $polynom_2bytes;
			}
				
			$VCID =  $payload_2bytes & $mask_VCID ;				# VCID = bits 10-15	
			
			# ----- process scrambling of CADU payload -----
		
			if ($xor)			# need to scramble / unscramble (same operation)
			{
				$payload_bytes = $payload_bytes ^ $polynom_bytes;		# XOR to scramble/descramble
			}
		
			# ----- prepare output -----
			
			if ($output)
			{
				if ($only_VCDU)
				{
					$out_bytes = substr $payload_bytes, 0, $B_VCDU;		# VCDU only
				}
				elsif ($no_ann)
				{
					$out_bytes = $SM_bytes.$payload_bytes;
				}
				else		# annotated CADU
				{
					$ann_bytes = substr $annCADU_bytes, $B_CADU, $B_ann;
					$out_bytes = $SM_bytes.$payload_bytes.$ann_bytes;
				}	
			}
				
			# ----- output unless idle frames are not wanted -----
			
			$VC_count{$VCID}++;			# VCID statistics
			
			$VC = unpack "n", $VCID;
		
			if ($no_idle)
			{
				if ($VCID ne $idle_VCID)
				{
					printf ",   non-idle CADU %8d", ++$n_niFRAMEs;
		
					if ($output)
					{
						if ($per_VCID)	{ $out = $outFRAMEs[$VC]; print $out $out_bytes; }
						else			{ print outFRAMEs $out_bytes; }
					}
				}
				else
				{
					printf ",   non-idle CADU %8d", $n_niFRAMEs;
				}
			}
			else
			{
					if ($output)
					{
						if ($per_VCID)	{ $out = $outFRAMEs[$VC]; print $out $out_bytes; }
						else			{ print outFRAMEs $out_bytes; }
					}
			}
			
			printf ",   VCID %2d", $VC;
			
			print "\r";			# print all log messages on the same line to avoid scrolling
		}
		else
		{
			$trailer_count = $bytes_read;
		}
	}
}
else		# input is VCDUs
{
	while ($bytes_read = read(inFRAMEs, $annVCDU_bytes, $B_annVCDU, 0))
	{
		if ($bytes_read == $B_annVCDU)
		{
			printf "VCDU %8d,   $bytes_read bytes", ++$n_FRAMEs;
			
			# ----- decode VCID -----
		
			$first_2bytes = substr $annVCDU_bytes, 0, 2;	# first 2 bytes
		
			$VCID =  $first_2bytes & $mask_VCID ;			# VCID = bits 10-15	
			
			# ----- prepare output -----
			
			if ($output)
			{
				if ($no_ann)
				{
					$out_bytes = substr $annVCDU_bytes, 0, $B_VCDU;		# VCDU only
				}
				else		# annotated VCDU
				{
					$out_bytes = $annVCDU_bytes;
				}	
			}
				
			# ----- output unless idle frames are not wanted -----
			
			$VC_count{$VCID}++;			# VCID statistics
		
			$VC = unpack "n", $VCID;

			if ($no_idle)
			{
				if ($VCID ne $idle_VCID)
				{
					printf ",   non-idle VCDU %8d", ++$n_niFRAMEs;
		
					if ($output)
					{
						if ($per_VCID)	{ $out = $outFRAMEs[$VC]; print $out $out_bytes; }
						else			{ print outFRAMEs $out_bytes; }
					}
				}
				else
				{
					printf ",   non-idle VCDU %8d", $n_niFRAMEs;
				}
			}
			else
			{
					if ($output)
					{
						if ($per_VCID)	{ $out = $outFRAMEs[$VC]; print $out $out_bytes; }
						else			{ print outFRAMEs $out_bytes; }
					}
			}		
			
			printf ",   VCID %2d", $VC;
			
			print "\r";			# print all log messages on the same line to avoid scrolling
		}
		else
		{
			$trailer_count = $bytes_read;
		}
	}
}

print "\n";					# final new line to leave the last message visible

print "$trailer_count trailer bytes dropped\n";		# report trailer bytes count

if ($stats)
{
	print "----- statistics -----\n";
			
	foreach $VCID (sort keys %VC_count)
	{
		printf "VCID %2d: %8d frames\n", (unpack "n", $VCID), $VC_count{$VCID};			
	}
}
close(inFRAMEs);

if ($output)
{
	print "----- output files -----\n";
			
	if ($per_VCID)
	{
		for ($VC = 0; $VC < 64; $VC++)
		{
			close($outFRAMEs[$VC]);
			
			if (-z $f_outFRAMEs[$VC])	{ unlink $f_outFRAMEs[$VC]; }	# if empty file, delete
			else						{ print "output file:   $f_outFRAMEs[$VC]\n"; }
		}
	}
	else
	{
		close(outFRAMEs);
		print "output file:   $f_outFRAMEs\n"; 
	}
}

print "----- DONE -----\n";
print "\n";					# final new line to leave the last message visible

exit 0;
